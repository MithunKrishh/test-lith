# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# monolith.yml â€” Generated by monolithx (simple mode)
#
# Single-job, single-file CI/CD workflow for Node.js.
# Runs in one job so Docker images built here are available to deploy steps
# on the same runner â€” no registry, no job isolation problems.
#
# To change the working directory (e.g. for a monorepo sub-folder):
#   1. Edit the WORK_DIR env var below, OR
#   2. Set the repository variable WORK_DIR in GitHub Settings â†’ Variables
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
name: Monolith CI/CD

on:
  push:
    branches:
      - "main"
      - "staging"
  pull_request:

concurrency:
  group: monolith-${{ github.ref }}
  cancel-in-progress: true

env:
  # Working directory â€” change this if your project lives in a sub-folder
  WORK_DIR: ${{ vars.WORK_DIR || '.' }}
  IMAGE_NAME: testing-lith
  PORT: 3000

jobs:
  # â”€â”€ Single job: CI â†’ Build â†’ Simulate Deploy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Everything runs on the same runner so the locally-built Docker image
  # is available for the deploy simulation without needing a registry.
  ci-build-deploy:
    name: "CI â†’ Build â†’ Deploy (testing-lith)"
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      # â”€â”€ 1. Checkout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Checkout repository
        uses: actions/checkout@v4

      # â”€â”€ 2. Set up Node.js â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Set up Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: "**/package-lock.json"

      # â”€â”€ 3. Install dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Install dependencies
        working-directory: ${{ env.WORK_DIR }}
        run: npm install --prefer-offline --no-audit --no-fund

      # â”€â”€ 4. Lint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Lint
        working-directory: ${{ env.WORK_DIR }}
        continue-on-error: true
        run: npm run lint --if-present

      # â”€â”€ 5. Test â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Run tests
        working-directory: ${{ env.WORK_DIR }}
        run: npm test --if-present

      # â”€â”€ 6. Build application â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Build application
        working-directory: ${{ env.WORK_DIR }}
        run: npm run build --if-present

      # â”€â”€ 7. Docker build â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Builds image locally on this runner with two tags:
      #   <image>:<git-sha>  â€” immutable, unique per commit
      #   <image>:latest     â€” mutable convenience tag
      # No push to a registry; the image lives on this runner for the deploy step.
      - name: Build Docker image
        working-directory: ${{ env.WORK_DIR }}
        run: |
          docker build \
            -t ${{ env.IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ env.IMAGE_NAME }}:latest \
            .

      # â”€â”€ 8. Verify image exists â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Verify Docker image was built
        run: |
          docker image inspect ${{ env.IMAGE_NAME }}:${{ github.sha }} \
            --format "Image ID: {{.Id}} | Created: {{.Created}}"

      # â”€â”€ 9. Simulate deployment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Runs the container on this runner to prove the image starts correctly.
      # In a real deployment, replace this step with SSH / kubectl / ecs deploy.
      - name: Simulate deployment (smoke test)
        run: |
          echo "ðŸš€ Starting container ${{ env.IMAGE_NAME }}:${{ github.sha }} on port ${{ env.PORT }}..."
          docker run -d \
            --name testing-lith-smoke \
            -p ${{ env.PORT }}:${{ env.PORT }} \
            ${{ env.IMAGE_NAME }}:${{ github.sha }}

          # Primary check: container hasn't exited â€” works for ANY Docker image
          # regardless of whether it exposes an HTTP endpoint.
          echo "â³ Waiting 15 s to confirm container stays running..."
          sleep 15
          STATE=$(docker inspect --format '{{.State.Running}}' testing-lith-smoke 2>/dev/null || echo "false")
          if [ "${STATE}" != "true" ]; then
            echo "âŒ Container exited unexpectedly. Last logs:"
            docker logs testing-lith-smoke
            exit 1
          fi
          echo "âœ… Container is still running â€” deployment simulation PASSED"

      # â”€â”€ 9b. HTTP health probe (informational â€” non-blocking) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Does NOT fail the job if your app doesn't expose HEALTH_PATH.
      # Covers any project without a dedicated HTTP health route.
      - name: HTTP health probe (informational)
        continue-on-error: true
        run: |
          echo "â„¹ï¸  Probing http://localhost:${{ env.PORT }}/health ..."
          for i in $(seq 1 10); do
            STATUS=$(curl -o /dev/null -s -w "%{http_code}" --max-time 3 \
              http://localhost:${{ env.PORT }}/health || echo "000")
            if [ "${STATUS}" -ge 200 ] && [ "${STATUS}" -lt 400 ]; then
              echo "âœ… Health endpoint responded HTTP ${STATUS} on attempt ${i}/10"
              exit 0
            fi
            echo "  attempt ${i}/10 â€” HTTP ${STATUS}"
            sleep 3
          done
          echo "â„¹ï¸  No HTTP 2xx on /health â€” app may not expose this route (non-fatal)"

      # â”€â”€ 10. Rollback-ready tag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Tags this SHA as the "previous" candidate so rollback can reference it.
      # In a registry-backed pipeline, you'd push both tags to GHCR here.
      - name: Tag image as rollback candidate
        run: |
          docker tag \
            ${{ env.IMAGE_NAME }}:${{ github.sha }} \
            ${{ env.IMAGE_NAME }}:previous
          echo "ðŸ”– Tagged ${{ env.IMAGE_NAME }}:${{ github.sha }} â†’ previous"

      # â”€â”€ 11. Cleanup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Stop smoke-test container
        if: always()
        run: |
          docker stop testing-lith-smoke 2>/dev/null || true
          docker rm   testing-lith-smoke 2>/dev/null || true
